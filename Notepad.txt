
***************THANKS TO DINESH VARYANI******************


public class Main
{
    LNode head;
    class LNode{
    int data;
    LNode next;
    LNode(int x){
        data=x;
        next=null;}
    }
	public static void main(String[] args) {
	    Main ll=new Main();
	    ll.addAtBegn(10);
	    ll.addAtBegn(20);
	    ll.addAtBegn(30);
	    ll.len();
	    ll.printList();
	    ll.addAtBegn(-20);
	    ll.addAtBegn(-10);
	    ll.len();
	    ll.printList();
	    ll.addAtEnd(-100);
	    ll.len();
	    ll.printList();
	    ll.addAtPos(69420,5);
	    ll.len();
	    ll.printList();
	    ll.delBegn();
	    ll.len();
	    ll.printList();
	    ll.delEnd();
	    ll.len();
	    ll.printList();
	    ll.delPos(3);
	    ll.len();
	    ll.printList();
	    ll.searchEle(69420);
	    ll.searchEle(77);
	    ll.head=ll.reverseLL();
	    ll.printList();
	    ll.nthNodeFromEnd(2);
	    ll.addAtBegn(-20);
	    ll.removeDupes();
	    ll.printList();
	}
	void len(){
        LNode temp=head;
        int l=0;
        while(temp!=null){
	    l++;
	    temp=temp.next;}
	    System.out.println("Length of List:"+l);
	    //return l;
    } 
    void addAtBegn(int d){
        LNode newNode=new LNode(d);
        newNode.next=head;
        head=newNode;
    }
    void addAtEnd(int d){
        LNode newNode=new LNode(d);
        LNode t=head;
        while(t.next!=null)
        t=t.next;
        t.next=newNode;
    }
    void addAtPos(int d,int pos){
        LNode newNode=new LNode(d);
        LNode t=head;
        int i=0;
        while(i!=pos-2){
            //System.out.println(t.data);
            i++;
            t=t.next;
        }
        newNode.next=t.next;
        t.next=newNode;
    }
    void delBegn(){
        head=head.next;
    }
    void delEnd(){
        LNode temp=head;
        while(temp.next.next!=null)
	    temp=temp.next;
	    temp.next=null;
    }
    void delPos(int pos){
        int i=0;
        LNode t=head;
        while(i!=pos-2)
        {
            i++;
            t=t.next;
        }
        t.next=t.next.next;
    }
    void printList(){
        LNode temp=head;
        int l=0;
        while(temp.next!=null){
	    System.out.print(temp.data+"->");
	    temp=temp.next;}
	    System.out.println(temp.data);
    }
    void searchEle(int d){
        int f=0,i=0;
        LNode t=head;
        while(t!=null)
        {
            i++;
            if(t.data==d)
            {
                System.out.println(d+" Found at position: "+i);
                return;
            }
            t=t.next;
        }
        System.out.println("Not Found");
        return; 
    }
    LNode reverseLL(){
        LNode curr=head;
        LNode next=null;
        LNode prev=null;
        while(curr!=null){
            next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
        }
        return prev;
    }
    void nthNodeFromEnd(int n){
        LNode temp=head;
        int l=0;
        while(temp!=null){
	    l++;
	    temp=temp.next;}
	    temp=head;
	    for(int i=0;i<l-n;i++)
	    temp=temp.next;
	    System.out.println(n+"th term from end is: "+temp.data);
    }
    boolean isin(int[] a,int x){
        for(int i=0;i<a.length;i++)
        if(x==a[i])
        return true;
        return false;
    }
    void removeDupes(){
        LNode t=head;
        int l=0;
        while(t!=null){
	    l++;
	    t=t.next;}
	    int i=0;
        int a[]=new int[l];
        t=head;
        LNode prev=null;
        while(t!=null){
            if(!isin(a,t.data))
            {a[i++]=t.data;
            prev=t;}
            else
            {
                prev=t;
                t.next=t.next.next;
            }
            t=t.next;
        }
        
    }
LNode loopedLL(){
	    LNode a=new LNode(83);
	    LNode b=new LNode(73);
	    LNode c=new LNode(63);
	    LNode d=new LNode(53);
	    LNode e=new LNode(43);
	    a.next=b;
	    b.next=c;
	    c.next=d;
	    d.next=e;
	    e.next=b;
	    return a;
	}
void checkLoopedList(){
        LNode p1=head,p2=head;
        while(p1!=null && p2!=null){
            p1=p1.next;
            p2=p2.next.next;
            if(p1==p2){
                System.out.println("Loopity Loop!");
                giveStartingNodeOfLoop(p1);
                removeLoop(p1);
                return;
            }
            
        }
        System.out.println("No Loops here!");
    }
    void giveStartingNodeOfLoop(LNode p1){
        LNode t=head;
        while(p1!=t){
            p1=p1.next;
            t=t.next;
            }
        System.out.println("Starting point is Node with data: "+t.data);
    }
    void removeLoop(LNode p1){
        LNode t=head;
        while(p1.next!=t.next){
            p1=p1.next;
            t=t.next;
            }
            p1.next=null;
    }
LNode mergeSortedLL(LNode a,LNode b){
        LNode t1=a,t2=b,t3=new LNode(0);
        LNode tt=t3;
        while(t1!=null&&t2!=null){
            if(t1.data<t2.data){
                tt.next=t1;
                t1=t1.next;
            }
            else{
                tt.next=t2;
                t2=t2.next;
            }
            tt=tt.next;
        }
        if(t1==null)
        tt.next=t2;
        else
        tt.next=t1;
        return t3.next;
    }
}

***************************New code*********************

public class Main
{
    Node head;
    class Node{
        int data;
        Node next;
        Node(int d){
            data=d;
            next=null;
        }
    }
	public static void main(String[] args) {
// 		Main ll=new Main();
// 		ll.addatBegn(5);
// 		ll.addatBegn(4);
// 		ll.addatBegn(3);
// 		ll.addatBegn(2);
// 		ll.addatBegn(1);
// 		ll.printList();
// 		System.out.println("Length of this list is: "+ll.len());
// 		Main ll2=new Main();
// 		ll2.addatBegn(15);
// 		ll2.addatBegn(14);
// 		ll2.addatBegn(13);
// 		ll2.addatBegn(12);
// 		ll2.addatBegn(11);
// 		ll2.addatBegn(9);
// 		ll2.printList();
// 		System.out.println("Length of this list is: "+ll2.len());
// 		ll.head=ll.addTwoLL(ll.head,ll2.head);
// 		ll.printList();
// 		System.out.println("Length of this list is: "+ll.len());
		Main firstNumber=new Main();
		Main secondNumber=new Main();
		firstNumber.addatBegn(9);
		firstNumber.addatBegn(4);
		firstNumber.addatBegn(7);
		firstNumber.printList();
		secondNumber.addatBegn(6);
		secondNumber.addatBegn(5);
		secondNumber.printList();
		Main sumOfThe2=new Main();
		sumOfThe2.head=sumOfThe2.add2LLRepresentingNumbers(firstNumber.head,secondNumber.head);
		sumOfThe2.printList();
	}
	void addatBegn(int d){
	    Node newNode=new Node(d);
	    newNode.next=head;
	    head=newNode;
	}
	int len(){
	    Node t=head;
	    int l=0;
	    while(t!=null){
	        t=t.next;
	        l++;
	    }
	    return l;
	}
	void printList(){
	    Node t=head;
	    while(t.next!=null){
	        System.out.print(t.data+"->");
	        t=t.next;
	    }
	    System.out.println(t.data);
	}
	int len(Node h){
	    Node t=head;
	    int l=0;
	    while(t!=null){
	        t=t.next;
	        l++;
	    }
	    return l;
	}
	Node addTwoLL(Node a,Node b){
	    Node t1=len(a)>len(b)?a:b;
	    Node t2=(t1==a)?b:a;
	    Node ans=t1;
	    while(t2!=null){
	        t1.data+=t2.data;
	        t1=t1.next;
	        t2=t2.next;
	    }
	    return ans;
	}
	Node add2LLRepresentingNumbers(Node a,Node b){
	    Node d=new Node(0);
	    Node t=d;
	    int c=0;
	    while(a!=null || b!=null){
	        int x=a!=null?a.data:0; 
	        int y=b!=null?b.data:0;
	        int s=c+x+y;
	        t.next=new Node(s%10);
	        t=t.next;
	        c=s/10;
	        //System.out.println("Sum= "+s+" Carry= "+c);
	        if(a!=null)a=a.next;
	        if(b!=null)b=b.next;
	    }
	    if(c!=0){
	        t.next=new Node(c);
	    }
	    return d.next;
	}
}

***************New Code DLL*****************************
public class Main
{
    Node head;
    class Node{
        int data;
        Node prev;
        Node next;
        Node(int d){
            data=d;
            prev=null;
            next=null;
        }
    }
	public static void main(String[] args) {
	    Main dll=new Main();
	    dll.addatBegn(5);
	    dll.addatBegn(4);
	    dll.addatBegn(3);
	    dll.addatBegn(2);
	    dll.addatBegn(1);
	    dll.printList();
	    dll.addAtEnd(8989);
	    dll.printList();
	    dll.delBegn();
	    dll.printList();
	    dll.delEnd();
	    dll.printList();
	}
	void addatBegn(int d){
	    Node newNode=new Node(d);
	    newNode.next=head;
	    if(head!=null)
	    head.prev=newNode;
	    head=newNode;
	}
	void addAtEnd(int d){
	    Node newNode=new Node(d);
	    Node t=head;
	    while(t.next!=null){
	        t=t.next;
	    }
	    t.next=newNode;
	    newNode.prev=t;
	}
	void delBegn(){
	    head.next.prev=null;
	    head=head.next;
	}
	void delEnd(){
	    Node t=head;
	    while(t.next.next!=null)
	    t=t.next;
	    t.next.prev=null;
	    t.next=null;
	}
	void printList(){
	    Node t=head;
	    while(t.next!=null){
	        if(t.prev==null)
	        System.out.print("[Prev: NULL"+", Data: "+t.data+", Next: "+t.next.data+"]->");
	        else
	        System.out.print("[Prev: "+t.prev.data+", Data: "+t.data+", Next: "+t.next.data+"]->");
	        t=t.next;
	    }
	    System.out.println("[Prev: "+t.prev.data+", Data: "+t.data+", Next: NULL]");
	}
}



***************New Code CLL********************************

public class Main
{
    Node tail;
    class Node{
        int data;
        Node next;
        Node(int d){
            data=d;
            next=null;
        }
    }
	public static void main(String[] args) {
	    Main cll=new Main();
	    cll.addBegn(2);
	    cll.addBegn(1);
	    cll.addEnd(3);
	    cll.printList();
	    cll.delBegn();
	    cll.delEnd();
	    cll.printList();
	}
	void addBegn(int d){
	    Node newNode=new Node(d);
	    if(tail==null){
	    newNode.next=newNode;
	    tail=newNode;}
	    else{
	    newNode.next=tail.next;
	    tail.next=newNode;}
	}
	void addEnd(int d){
	    Node newNode=new Node(d);
	    if(tail==null){
	        tail=newNode;
	        newNode.next=newNode;
	    }
	    else{
	        newNode.next=tail.next;
	        tail.next=newNode;
	        tail=newNode;
	    }
	}
	void delBegn(){
	    if(tail.next==tail)
	    tail=null;
	    else
	    {
	        tail.next=tail.next.next;
	    }
	}
	void delEnd(){
	    if(tail.next==tail)
	    tail=null;
	    else{
	        Node t=tail.next;
	        while(t.next!=tail){
	            t=t.next;
	        }
	        t.next=t.next.next;
	        tail=t;
	    }
	}
	void printList(){
	    if(tail.next==tail)
	    System.out.println(tail.data);
	    else{
	        Node t= tail.next;
	        while(t!=tail){
	            System.out.print(t.data+"->");
	            t=t.next;
	        }
	        System.out.println(t.data);
	    }
	}
}

************************ New Code Stack using LL*******

public class Main
{
    Node top;
    class Node{
        int data;
        Node next;
        Node(int d){
            data=d;
            next=null;
        }
    }
	public static void main(String[] args) {
		Main stack=new Main();
		stack.push(2);
		stack.push(3);
		System.out.println("Popped: "+stack.pop());
	}
	void push(int d){
	    Node newNode=new Node(d);
	    newNode.next=top;
	    top=newNode;
	}
	int pop(){
	    if(top==null){
	        return -999999;
	    }
	    int x=top.data;
	    top=top.next;
	    return x;
	}
}

********************New Code Reverse String using Stack********

//REVERSE STRING USING STACK IN JAVA
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main
{
	public static void main(String[] args) {
	    Stack <Character> s=new Stack<>();
	    String str="ABCD";
	    for(int i=0;i<str.length();i++)
	    s.push(str.charAt(i));
	    String t="";
	    while(!s.isEmpty()){
	        t+=s.pop();
	    }
	    System.out.println(t);
	}
}

****************NEXT GREATER ELEMENT************
static int[] nextGreaterElement(int[] a){
	    int r[]=new int[a.length];
	    Stack <Integer> s=new Stack<>();
	    for(int i=a.length-1;i>=0;i--){
	        if(!s.isEmpty()){
	            while(!s.isEmpty()&&s.peek()<=a[i])
	            s.pop();
	        }
	        if(s.isEmpty())
	        r[i]=-1;
	        else
	        r[i]=s.peek();
	        s.push(a[i]);
	    }
	    return r;
	}

**************VALID PARENTHESES****************************

static boolean validBrackets(String p){
	    Stack <Character> s=new Stack<>();
	    int i=0;
	    while(i<p.length()){
	        if("([{".indexOf(p.charAt(i))!=-1)
	        s.push(p.charAt(i));
	        else{
	            if(!s.isEmpty()&&s.peek()=='(' && p.charAt(i)==')')
	            s.pop();
	            else if(!s.isEmpty()&&s.peek()=='[' && p.charAt(i)==']')
	            s.pop();
	            else if(!s.isEmpty()&&s.peek()=='{' && p.charAt(i)=='}')
	            s.pop();
	            else
	            return false;
	        }i++;
	    }
	    return s.isEmpty();
	}

*********************QUEUE LL******************************

//QUEUE
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main
{
    Node front,rear;
    class Node{
        int data;
        Node next;
        Node(int d){
            data=d;
            next=null;
        }
    }
	public static void main(String[] args) {
		Main q=new Main();
		q.enqueue(5);
		q.enqueue(4);
		q.enqueue(3);
		q.enqueue(2);
		q.enqueue(1);
		q.printQueue();
		System.out.println("Dequeued data: "+q.dequeue());
		q.printQueue();
	}
	void enqueue(int d){
	    Node newNode=new Node(d);
	    if(rear==null){
	    rear=newNode;
	    front=newNode;}
	    else{
	    rear.next=newNode;
	        rear=newNode;
	    }
	}
	int dequeue(){
	    int x=front.data;
	    front=front.next;
	    return x;
	}
	void printQueue(){
	    Node t=front;
	    while(t.next!=null){
	    System.out.print(t.data+", ");
	    t=t.next;}
	    System.out.println(t.data);
	}
}

********************Generate Binary from 1 to n************

static void generateBinary1toN(int n){
	    Queue<String> q=new LinkedList<>();
	    q.add("1");int i=0;
	    while(i<n){
	        String x=q.remove();
	        System.out.println(x);
	        q.add(x+"0");
	        q.add(x+"1");
	        i++;
	    }
	}

****************BINARY TREE and all 4 traversals and max value of tree***************************

//BINARY TREE
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main
{
    Node root;
    class Node{
        int data;
        Node left,right;
        Node(int d){
            data=d;
            left=null;
            right=null;
        }
    }
	public static void main(String[] args)throws IOException {
	   Main bt=new Main();
	   bt.root=bt.createBinaryTree();
	   System.out.println("Pre Order:");
	   bt.preOrderTaversal(bt.root);
	   System.out.println("Post Order:");
	   bt.postOrderTaversal(bt.root);
	   System.out.println("In Order:");
	   bt.inOrderTaversal(bt.root);
	}
	Node createBinaryTree(){
	    Node a=new Node(1);
	    Node b=new Node(2);
	    Node c=new Node(3);
	    Node d=new Node(4);
	    Node e=new Node(5);
	    a.left=b;
	    a.right=c;
	    b.left=d;
	    b.right=e;
	    return a;
	}
	void preOrderTaversal(Node root){
	    if(root==null)
	    return;
	    System.out.println(root.data);
	    preOrderTaversal(root.left);
	    preOrderTaversal(root.right);
	}
	void postOrderTaversal(Node root){
	    if(root==null)
	    return;
	    postOrderTaversal(root.left);
	    postOrderTaversal(root.right);
	    System.out.println(root.data);
	}
	void inOrderTaversal(Node root){
	    if(root==null)
	    return;
	    inOrderTaversal(root.left);
	    System.out.println(root.data);
	    inOrderTaversal(root.right);
	}

	void levelOrderTraversal(Node root){
	    if(root==null)
	    return;
	    Queue<Node> q=new LinkedList<>();
	    q.add(root);
	    while(!q.isEmpty()){
	        Node t=q.remove();
	        System.out.print(t.data+", ");
	        if(t.left!=null)
	        q.add(t.left);
	        if(t.right!=null)
	        q.add(t.right);
	    }
	}
int findMaxValue(Node root){
	    if(root==null)
	    return Integer.MIN_VALUE;
	    if(root.left==null && root.right==null)
	    return root.data;
	    return Math.max(Math.max(findMaxValue(root.right),findMaxValue(root.left)),root.data);
	}
}

*************************BST******************************

//BINARY TREE
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main
{
    Node root;
    class Node{
        int data;
        Node left,right;
        Node(int d){
            data=d;
            left=null;
            right=null;
        }
    }
	public static void main(String[] args)throws IOException {
	   Main bst=new Main();
	   bst.root=null;
	   bst.root=bst.insertToBST(30);
	   bst.root=bst.insertToBST(10);
	   bst.root=bst.insertToBST(20);
	   bst.root=bst.insertToBST(40);
	   bst.root=bst.insertToBST(50);
	   bst.root=bst.insertToBST(5);
	   bst.root=bst.insertToBST(45);
	   bst.inOrderTaversal(bst.root);
	   System.out.println(bst.searchBST(bst.root,45));
	   System.out.println(bst.searchBST(bst.root,0));
	   System.out.println(bst.validateBST(bst.root,Integer.MAX_VALUE,Integer.MIN_VALUE));
	}
	Node insertToBST(int d){
	    Node newNode=new Node(d);
	    if(root==null)
	    {
	        root=newNode;return root;
	    }
	    Node t=root;
	    while(true){
	        if(d<t.data){
	            if(t.left!=null)
	            t=t.left;
	            else{
	            t.left=newNode;return root;}
	        }
	        else if(d>t.data){
	            if(t.right!=null)
	            t=t.right;
	            else{
	            t.right=newNode;return root;}
	        }
	    }
	}
	void preOrderTaversal(Node root){
	    if(root==null)
	    return;
	    System.out.println(root.data);
	    preOrderTaversal(root.left);
	    preOrderTaversal(root.right);
	}
	void postOrderTaversal(Node root){
	    if(root==null)
	    return;
	    postOrderTaversal(root.left);
	    postOrderTaversal(root.right);
	    System.out.println(root.data);
	}
	void inOrderTaversal(Node root){
	    if(root==null)
	    return;
	    inOrderTaversal(root.left);
	    System.out.println(root.data);
	    inOrderTaversal(root.right);
	}
	void levelOrderTraversal(Node root){
	    if(root==null)
	    return;
	    Queue<Node> q=new LinkedList<>();
	    q.add(root);
	    while(!q.isEmpty()){
	        Node t=q.remove();
	        System.out.print(t.data+", ");
	        if(t.left!=null)
	        q.add(t.left);
	        if(t.right!=null)
	        q.add(t.right);
	    }
	}
	boolean searchBST(Node root,int k){
	    if(root==null)
	        return false;
	    if(root.data==k)
	    return true;
	    else if(root.data<k)
	    return searchBST(root.right,k);
	    else
	    return searchBST(root.left,k);
	}
	boolean validateBST(Node root,int x,int y){
	    if(root==null)
	    return true;
	    if(root.data<x && root.data>y){
	        return validateBST(root.left,root.data,y) && validateBST(root.right,x,root.data);
	    }
	    else
	    return false;
	}
}

**************Find value in row and columnwise sorted Matrix*********************
//SEARCH IN ROW AND COLUMNWISE SORTED MATRIX
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main
{
	public static void main(String[] args) {
	    Main obj=new Main();
	    int a[][]= {{ 10, 20, 30, 40 },
                    { 15, 25, 35, 45 },
                    { 27, 29, 37, 48 },
                    { 32, 33, 39, 50 }};
		System.out.println(obj.searchSortedMatrix(a,28));
	}
	static boolean searchSortedMatrix(int[][] a,int x){
	    int i=0,j=0,n=a[0].length;
	    j=n-1;
	    while(i<n && j>=0){
	        if(a[i][j]==x)
	        return true;
	        else{
	            if(a[i][j]<x)
	            i++;
	            else
	            j--;
	        }
	    }
	    return false;
	}
}

*****************************SPIRAL MATRIX PRINT********
void printSpiral(int[][] a){
	    int n=a.length,m=a[0].length;
	    int rs=0,cs=0,rl=n-1,cl=m-1;
	    while(rs<=rl && cs<=cl){
	        for(int i=cs;i<=cl;i++)
	        System.out.print(a[rs][i]+" ");
	        System.out.println();
	        rs++;
	        for(int i=rs;i<=rl;i++)
	        System.out.print(a[i][cl]+" ");
	        System.out.println();
	        cl--;
	        for(int i=cl;i>=cs;i--)
	        System.out.print(a[rl][i]+" ");
	        System.out.println();
	        rl--;
	        for(int i=rl;i>=rs;i--)
	        System.out.print(a[i][cs]+" ");
	        System.out.println();
	        cs++;
	    }
	}

****************************PRIORITY QUEUE AND BINARY HEAP**************
//PRIORITY QUEUE USING BINARY HEAP(MIN HEAP AND MAX HEAP)
import java.lang.*;
import java.io.*;
import java.util.*;
//first entry of array always empty, children are 2k and 2k+1
public class Main
{
    private Integer heap[];
    private  int n;
    Main(int cap){
    heap=new Integer[cap+1];
    n=0;
    }
    public void insert(int x){
        if(n==heap.length-1)
            resize(2*heap.length);
        heap[++n]=x;
        reHeapifyBottomUpMaxHeap(n);
    }
    public void insertMinh(int x){
        if(n==heap.length-1)
            resize(2*heap.length);
        heap[++n]=x;
        reHeapifyBottomUpMinHeap(n);
    }
    public int deleteMax(){
        int x=heap[1];
        heap[1]=heap[--n];
        heap[n+1]=null;
        reHeapifyTopDownMaxHeap(1);
        if(n>0 && n==(heap.length-1)/4)
            resize(heap.length/2);
        return x;
    }
    public int deleteMin(){
        int x=heap[1];
        heap[1]=heap[--n];
        heap[n+1]=null;
        reHeapifyTopDownMinHeap(1);
        if(n>0 && n==(heap.length-1)/4)
            resize(heap.length/2);
        return x;
    }
    private void reHeapifyTopDownMaxHeap(int k){
        if(k==n || 2*k>=n)
            return;
        int j=2*k;
        if(j<n && heap[j+1]>heap[j])
            j++;
        if(heap[k]<heap[j]) {
            int t=heap[j];
            heap[k]=heap[j];
            heap[j]=t;
            reHeapifyTopDownMaxHeap(j);
        }
    }
    private void reHeapifyTopDownMinHeap(int k){
        if(k==n || 2*k>=n)
            return;
        int j=2*k;
        if(j<n && heap[j+1]<heap[j])
            j++;
        if(heap[k]>heap[j]) {
            int t=heap[j];
            heap[k]=heap[j];
            heap[j]=t;
            reHeapifyTopDownMinHeap(j);
        }
    }
    private void reHeapifyBottomUpMaxHeap(int k){//MAX PRIORITY QUEUE SATISFIED
        while(k>1&&heap[k/2]<heap[k]){
            int t=heap[k];
            heap[k]=heap[k/2];
            heap[k/2]=t;
            k/=2;
        }
    }
    private void reHeapifyBottomUpMinHeap(int k){
        while(k>1&&heap[k/2]>heap[k]){
            int t=heap[k];
            heap[k]=heap[k/2];
            heap[k/2]=t;
            k/=2;
        }
    }
    private void resize(int cap){
        Integer t[]=new Integer[cap];
        for(int i=0;i<heap.length;i++)
            t[i]=heap[i];
        heap=t;
    }
    public boolean isempty(){
        return n==0;
    }
    public void printHeap(){
        for(int i=0;i<=n;i++)
            System.out.print(heap[i]+ " ");
        System.out.println();
    }
    public static void main(String[] args) {
        Main minh=new Main(3);
        Main maxh=new Main(3);
        maxh.insert(9);
        maxh.insert(3);
        maxh.insert(12);
        maxh.insert(7);
        maxh.insert(17);
        maxh.insert(70);
        maxh.insert(27);
        maxh.printHeap();
        System.out.println("Maximum Element: "+maxh.deleteMax());
        maxh.printHeap();
        minh.insertMinh(9);
        minh.insertMinh(3);
        minh.insertMinh(12);
        minh.insertMinh(7);
        minh.insertMinh(17);
        minh.insertMinh(70);
        minh.insertMinh(27);
        minh.printHeap();
        System.out.println("Minimum Element: "+minh.deleteMin());
        minh.printHeap();
    }
}

********************************INSERTION SORT************

import java.lang.*;
import java.io.*;
import java.util.*;
public class Main
{
    Main(int cap){
    }
    public static void InsertionSort(int[] a){
        for(int i = 1; i < a.length; i++){
            int j=i;
            int x=a[i];
            while(j!=0 && a[j-1]>x){
                a[j]=a[j-1];
                j--;
            }
            a[j]=x;
        };
    }
    public static void main(String[] args) {
        int a[]={3,5,12,4,9,20,1,34,26};
        InsertionSort(a);
        for(int i : a) {
            System.out.print(i + " ");
        }
    }
}

****************SEARCH INSERT PROBLEM************
//SEARCH INSERT PROBLEM
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main
{
    public static int searchInsert(int[] a,int x){
        int l=0,h=a.length-1;
        int mid=0;
        while(l<=h){
            mid=(h+l)/2;
            if(a[mid]==x){
                return mid;
            }
            if(a[mid]<x){
                l=mid+1;
            }
            else
                h=mid-1;
        }
        return a[mid]<x?mid+1:mid;
    }
    public static void main(String[] args) {
        int a[]={1,3,5,7};
        System.out.println(searchInsert(a,2));
        System.out.println(searchInsert(a,3));
        System.out.println(searchInsert(a,9));
        System.out.println(searchInsert(a,4));
        System.out.println(searchInsert(a,5));
    }
}

**************************SELECTION SORT****************

//SELECTION SORT
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main
{
    public static void SelectionSort(int[] a){
        for(int i=0; i<a.length-1; i++){
            int sm_i=i;
            for(int j=i+1; j<a.length; j++){
                if(a[j]<a[sm_i]){
                    sm_i=j;
                }
            }
            if(i!=sm_i)
            {
                int temp=a[sm_i];
                a[sm_i]=a[i];
                a[i]=temp;
            }
        }
    }
    public static void main(String[] args) {
        int a[]={3,2,1,5,9,6,7};
        SelectionSort(a);
        for(int i=0; i<a.length; i++)
            System.out.print(a[i]+" ");
    }
}

*********************************MERGE SORTED ARRAYS**************
package org.example;
//MERGE 2 SORTED ARRAYS
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main
{
    public static int[] MergeSortedArrays(int[] a,int[] b){
        int i=0,j=0,k=0;
        int[] res=new int[a.length+b.length];
        while(i<a.length && j<b.length){
            if(a[i]<b[j]){
                res[k++]=a[i++];
            }
            else
                res[k++]=b[j++];
        }
        while(j<b.length){
                res[k++]=b[j++];
            }
        while(i<a.length){
                res[k++]=a[i++];
            }
        return res;
    }
    public static void main(String[] args) {
        int a[]={1,2,3,4,5,6,7,9};
        int b[]={1,3,5,7,8};
        a=MergeSortedArrays(a,b);
        for(int i=0; i<a.length; i++)
            System.out.print(a[i]+" ");
    }
}

****************************MERGE SORT**********************

package org.example;
//MERGE SORT
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main
{
    public static void MergeSort(int[] a,int[] t,int l,int h){
        if(l<h){
        int m=l+(h-l)/2;
        MergeSort(a,t,l,m);
        MergeSort(a,t,m+1,h);
        Merge(a,t,l,m,h);}
    }
    public static void Merge(int[] a,int[] t,int l,int m,int h){
        for(int i=l;i<=h;i++)
            t[i]=a[i];
        int i=l,j=m+1,k=l;
        while(i<=m && j<=h){
            if(t[i]<t[j]){
                a[k++]=t[i++];
            }
            else
                a[k++]=t[j++];
        }
        while(i<=m){
            a[k++]=t[i++];
        }
    }
    public static void main(String[] args) {
        int a[]={3,2,1,5,9,6,7};
        int t[]=new int[a.length];
        int l=0,h=a.length-1;
        MergeSort(a,t,l,h);
        for(int i=0; i<a.length; i++)
            System.out.print(a[i]+" ");
    }
}

***************DUTCH NATIONAL FLAG PROBLEM(SORT ARRAY OF 0/1/2)*******************

public static void sort(int[] a){
        int i=0,j=0,k=a.length-1;
        while(i<=k){
            if(a[i]==0){
                int t=a[i];
                a[i]=a[j];
                a[j]=t;
                i++;
                j++;
            }
            else if(a[i]==1)
                i++;
            else{
                int t=a[j];
                a[i]=a[k];
                a[k]=t;
                k--;
            }
        }
    }

********************QUICK SORT***********************

package org.example;
//QUICK SORT
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main
{
//Select Pivot
//All greater than it one side, and rest other, now pivot is sorted
//2 subarrays formed, left and right, sort them recursively, array is sorted #D&C
    public static void QuickSort(int[] a,int low,int high){
        if(low<high){
            int pivot = partition(a,low,high);
            QuickSort(a,low,pivot-1);
            QuickSort(a,pivot+1,high);
        }
    }
    public static int partition(int[] a, int low, int high){
        int pivot = a[high];
        int i=low,j=low;
        while(i<=high){
            if(a[i]<=pivot){
                int t=a[i];
                a[i]=a[j];
                a[j]=t;
                j++;
            }
            i++;
        }
        return j-1;
    }
    public static void main(String[] args) {
        int a[]={2, 1, 0, 1, 2, 0, 1, 2, 0, 1};
        QuickSort(a,0,a.length-1);
        for(int i=0; i<a.length; i++)
            System.out.print(a[i]+" ");
    }
}


**************************SQUARES OF SORTED ARRAY*********************


    public static int[] SquaresOfSorted(int[] a){
        int[] b = new int[a.length];
        int i=0,j=a.length-1,k=a.length-1;
        while(k>=0){
            if(Math.abs(a[i])>Math.abs(a[j]))
                b[k--]=(int)Math.pow(a[i++],2);
            else
                b[k--]=(int)Math.pow(a[j--],2);
        }
        return b;
    }

******************************Rearrange Sorted Array in max/min form******************

public static int RearrangeSortedArrayInMaxMin(int[] a){
        int minind=0;
        int maxind=a.length-1;
        int maxval=a[a.length-1]+1;
        for(int i=0;i<a.length;i++){
            if(i%2==0){
                a[i]=a[i]+((a[maxind]%maxval)*maxval);
                maxind--;
            }
            else{
                a[i]=a[i]+((a[minind]%maxval)*maxval);
                minind++;
            }
        }
        return maxval;
    }

****************************************Graphs and Traversals**************

//GRAPH
//Adjacency Matrix me 0/1 if there is an edge between the 2 vertices (V*V Matrix)
//Adjacency List me Linked List representation, array of Linked , separate lists of their adjacent vertices
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main {
    int [][] adjMatrixGraph;
    Main(int n){
        adjMatrixGraph=new int[n][n];
    }
    public void addEdge(int u, int v){
        adjMatrixGraph[u][v]=1;
        adjMatrixGraph[v][u]=1;
    }
    public void BFS(int s){
        int n=adjMatrixGraph.length;
        boolean vis[]=new boolean[adjMatrixGraph.length];
        Queue<Integer> queue=new LinkedList<>();
        queue.add(s);
        vis[s]=true;
        while(!queue.isEmpty()){
            int x=queue.remove();
            System.out.print(x+" ");
            for(int u=0;u<n;u++){
                if(adjMatrixGraph[x][u]==1 && vis[u]==false){
                    queue.add(u);
                    vis[u]=true;
                }
            }
        }
    }
    public void DFS(int s){
        int n=adjMatrixGraph.length;
        boolean vis[]=new boolean[adjMatrixGraph.length];
        Stack<Integer> stack=new Stack<>();
        stack.push(s);
        vis[s]=true;
        while(!stack.isEmpty()){
            int x=stack.pop();
            System.out.print(x+" ");
            for(int u=0;u<n;u++){
                if(adjMatrixGraph[x][u]==1 && vis[u]==false){
                    stack.push(u);
                    vis[u]=true;
                }
            }
        }
    }
    public void print(){
        for(int i=0;i<adjMatrixGraph.length;i++){
            for(int j=0;j<adjMatrixGraph[i].length;j++){
                System.out.print(adjMatrixGraph[i][j]+" ");
            }
            System.out.println();
        }
    }
    public static void main(String[] args) {
        Main main=new Main(4);
        main.addEdge(0,1);
        main.addEdge(0,2);
        main.addEdge(1,2);
        main.addEdge(2,3);
        main.print();
        main.BFS(0);
        System.out.println();
        main.DFS(0);
    }
}

************CONNECTED COMPONENTS*************************

DO DFS
GIVE COMP ID (COUNT) FOR EACH DFS VERTICES
SAME COMP ID ONES ARE CONNECTED

*****************************NUMBER OF ISLANDS**************

//NUMBER OF ISLANDS
//You are given a 2-D matrix surface of size n*m . Each cell of the surface is either 1 (land) or 0 (water).
// Find the number of islands on the surface.
// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.
public void DFS(int[][] adjMatrixGraph,boolean[][] vis,int i,int j){
        if(i<0 || j<0 || i>=adjMatrixGraph.length || j>=adjMatrixGraph.length){
            return;
        }
        if(vis[i][j] || adjMatrixGraph[i][j]==0)
            return;
        vis[i][j]=true;
        DFS(adjMatrixGraph,vis,i,j-1);
        DFS(adjMatrixGraph,vis,i,j+1);
        DFS(adjMatrixGraph,vis,i-1,j);
        DFS(adjMatrixGraph,vis,i+1,j);
    }
    public int NumberOfIslands(int[][] a){
        int ans=0;
        int n=a.length;
        boolean vis[][]=new boolean[a.length][a.length];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++)
            if(vis[i][j]==false && a[i][j]==1){
                DFS(a,vis,i,j);
                ans++;
            }
        }
        return ans;
    }

****************HASHING***********************************

Array Direct Adressing - O(1) using indexes
Fails in examples like Aadhar Number (12 digits)
Waste of space and huge space reqs

Hash Funcs: Take arbitrary size key and give fixed size value.
Modular Hash Func: Key and size, returns key%size.
Hash Table is a generalized form of an array.
Data stored in Key-Value Pair.
Convert key to index using hash func. Store pair there.
Operations supported by Hash Table are:
PUT(K,V)
GET(K)
REMOVE(K)
O(1) average running time.
HashMap class in Java. Only keys - HashSet.
Dictionary in Python.

Collision occurs when pair already exists at calculated index.

COLLISION RESOLUTION (SEPARATE CHAINING)
Store both values in a Linked List which resides at that index.
(That's why called Separate "Chaining").
So here we have HashNodes (K,V,Next).

package org.example;
//HASHING via HashTable having HashNodes (Separate Chaining)
import java.lang.*;
import java.io.*;
import java.util.*;
public class Main {
    HashNode[] buckets;
    int numOfBuckets;
    int size;
    class HashNode{
        int k;
        String v;
        HashNode next;
        HashNode(int k,String v){
        this.k=k;
        this.v=v;
        next=null;}
    }
    Main(int capacity){
        buckets=new HashNode[capacity];
        numOfBuckets=capacity;
        size=0;
    }
    public void Put(int k,String v){
        int index=k%numOfBuckets;
        //System.out.println(index);
        HashNode head=buckets[index];
        while(head!=null){
            //System.out.println(head.v);
            if(head.k==k){
                head.v=v;
                return;
            }
            head=head.next;
        }
        head=buckets[index];
        HashNode newnode=new HashNode(k,v);
        newnode.next=head;
        buckets[index]=newnode;
        size++;
    }
    public String Get(int k){
        int index=k%numOfBuckets;
        HashNode head=buckets[index];
        while(head!=null){
            if(head.k==k){
                return head.v;
            }
            head=head.next;
        }
        return "Error: Value Not Found";
    }
    public String Remove(int k){
        int index=k%numOfBuckets;
        HashNode head=buckets[index];
        HashNode prev=head;
        if(head.k==k){
            if(head.next==null){
                String x=head.v;
                buckets[index]=null;
                size--;
                return x;
            }
        }
        while(head!=null){
            if(head.k==k){
                prev.next=head.next;
                String x=head.v;
                size--;
                return x;
            }
            prev=head;
            head=head.next;
        }
        return "Error: Value Not Found";
    }
    public static void main(String[] args) {
        Main HashTable=new Main(10);
        HashTable.Put(105,"Raghav");
        HashTable.Put(21,"Reena");
        HashTable.Put(43,"Jeena");
        HashTable.Put(105,"Meena");
        System.out.println(HashTable.size);
        System.out.println(HashTable.Get(105));
        System.out.println(HashTable.Remove(105));
        System.out.println(HashTable.size);
        System.out.println(HashTable.Get(105));
    }
}

***************CONTAINS DUPLICATE*********************
return true if array contains duplicate

public boolean containsDuplicates(int[] a){
        int modval=a[0];
        for(int i=0;i<a.length;i++)
            if(modval<a[i])
                modval=a[i];
        Integer hashTable[]=new Integer[modval+1];
        for(int i=0;i<a.length;i++){
            if(hashTable[a[i]%modval]!=null)
                return true;
            hashTable[a[i]%modval]=a[i];
        }
        return false;
    }
    public boolean containsDuplicatesUsingInbuiltSetDS(int[] a){
        Set<Integer> hashTable=new HashSet<>();
        for(int i=0;i<a.length;i++){
            if(hashTable.contains(a[i]))
                return true;
            hashTable.add(a[i]);
        }
        return false;
    }

*******************Overlapping Intervals***************

*******************Return Non Overlapping Intervals*********************

public List<Interval> ReturnNonOverlappingIntervals(List<Interval> ints){
        List<Interval> res=new LinkedList<>();
        ints.sort(Comparator.comparingInt(in->in.s));
        Interval curr=ints.get(0);
        for(int i=1;i<ints.size();i++){
            if(curr.e>ints.get(i).s){
                curr.e=Math.max(curr.e,ints.get(i).e);
            }
            else{
                res.add(new Interval(ints.get(i).s,ints.get(i).e));
            }
            curr.s=ints.get(i).s;
            curr.e=ints.get(i).e;
        }
        return res;
    }

*************Insert Interval In Sorted List of Intervals and Merge Overlapping********

public List<Interval> InsertIntoSortedIntervals(List<Interval> ints,Interval newInterval){
        List<Interval> res=new LinkedList<>();
        ints.sort(Comparator.comparingInt(in->in.s));
        int i=0;
        while(i<ints.size() && newInterval.s>ints.get(i).e){
            res.add(ints.get(i));
        }
        while(i<ints.size() && newInterval.e>=ints.get(i).s){
            newInterval.s=Math.min(ints.get(i).s,newInterval.s);
            newInterval.e=Math.max(ints.get(i).e,newInterval.e);
            i++;
        }
        res.add(newInterval);
        while(i<ints.size()){
            res.add(ints.get(i));i++;}
        return res;
    }

***************Merge Overlapping Intervals********************

public static List<Interval> MergeOverlappingIntervals(List<Interval> ints){
        List<Interval> res=new LinkedList<>();
        ints.sort(Comparator.comparingInt(in->in.s));
        Stack<Interval> s=new Stack<>();
        s.push(ints.get(0));
        int i=1;
        while(i<ints.size()){
            if(!s.empty() && s.peek().e>=ints.get(i).s){
                Interval t=s.pop();
                t.s=Math.min(t.s,ints.get(i).s);
                t.e=Math.max(t.e,ints.get(i).e);
                s.push(t);
            }
            else
            s.push(ints.get(i));
            i++;
        }
        for(Interval t:s){
            res.add(t);
        }
        for(Interval t:res){
            System.out.println(t.s+" "+t.e);
        }
        return res;
    }

**********************Trie (add and search)****************

reTRIEve stored info fast
(autocomplete, search suggest in list, spell check)

import java.lang.*;
import java.util.*;
//TRIE
public class Main {
    TrieNode root;
    class TrieNode{
        TrieNode[] children;
        boolean isWord;
        public TrieNode(){
            this.children = new TrieNode[26];
            this.isWord = false;
        }
    }
    Main(){
        root=new TrieNode();
    }
    public void add(String word){
        TrieNode curr=root;
        int i=0;
        while(i<word.length() && curr.children[word.charAt(i)-'a']!=null){
            curr=curr.children[word.charAt(i)-'a'];
            i++;
        }
        while(i<word.length()){
            curr.children[word.charAt(i)-'a']=new TrieNode();
            curr=curr.children[word.charAt(i)-'a'];
            i++;
        }
        curr.isWord=true;
    }
    public boolean search(String word){
        TrieNode curr=root;
        int i=0;
        while(i<word.length() && curr.children[word.charAt(i)-'a']!=null){
            curr=curr.children[word.charAt(i)-'a'];
            i++;
        }
        if(curr.isWord && i==word.length())
            return true;
        return false;
    }
    public static void main(String[] args) {
        Main Trie = new Main();
        Trie.add("hello");
        System.out.println(Trie.search("hello"));
        Trie.add("heat");
        System.out.println(Trie.search("heal"));
        System.out.println(Trie.search("heat"));
        System.out.println(Trie.search("he"));
    }
}

*************************DP*****************************

Jonathon Paulson on Quora (1+1+1+..... explanation)

Bottom Up -> Tabulation Approach
Top Down -> Memoization

****************FIBONACCI***********
int Fibonacci(int n) {
        ArrayList<Integer> fib=new ArrayList<>();
        fib.add(0);
        fib.add(1);
        for(int i=2;i<=n;i++) {
            fib.add(fib.get(fib.size()-1)+fib.get(fib.size()-2));
        }
        return fib.get(n);
    }

*********************MAX SUBARRAY SUM KADANE***************

int maxSumSubarrayKadane(int[] a) {
        int maxhere=0,maxsofar=0;
        for(int i=0;i<a.length;i++) {
            maxhere+=a[i];
            if(maxhere<0)
                maxhere=0;
            if(maxsofar<maxhere) {
                maxsofar=maxhere;
            }
            //System.out.println(maxhere+" "+maxsofar);
        }
        return maxsofar;
    }

************************Two Sum************************

boolean twosum(int[] a,int x){
        Arrays.sort(a);
        int i=0,j=a.length-1;
        while(i<j){
            if((a[i]+a[j])==x)
                return true;
            if(a[i]+a[j]<x)
                i++;
            else
                j--;
        }
        return false;
    }

Better approach Using Hashing


    boolean twosumHashing(int[] a,int x){
        Map m=new HashMap();
        for(int i=0;i<a.length;i++){
            if(!m.containsKey(x-a[i])){
                m.put(a[i],i);
            }
            else
                return true;
        }
        return false;
    }
*************************Is Subsequence*********************

boolean isSubsequence(String a,String b){
        int i=0,j=0;
        while(i<a.length()&&j<b.length()){
            if(a.charAt(i)==b.charAt(j)){
                j++;
            }
            i++;
        }
        if(j==b.length()){
            return true;
        }
        return false;
    }

***************First Non Repeating Character*************

int firstNonRepeatingChar(String str) {
        Map m=new HashMap();
        for(int i=0;i<str.length();i++) {
            if(!m.containsKey(str.charAt(i))) {
                m.put(str.charAt(i),1);
            }
            else{
                int c=(int)m.get(str.charAt(i));
                m.put(str.charAt(i),c+1);
            }
        }
        for(int i=0;i<str.length();i++) {
            if((int)m.get(str.charAt(i))==1)
                return i;
        }
        return -1;
    }

**********************Remove Vowels********************

String removeVowels(String str) {
        char s[]=str.toCharArray();
        String res="";
        Set<Character> vows=Set.of('a','e','i','o','u');
        for(int i=0;i<str.length();i++) {
            if(!vows.contains(s[i]))
                res+=str.charAt(i);
        }
        return res;
    }

*********************Reverse Integer************************

    int ReverseInteger(int n) {
        int res=0,flag=n<0?1:0;
        n=Math.abs(n);
        while(n!=0) {
            int p=n%10;
            res=res*10+p;
            n=n/10;

        }
        return flag==1?(res*-1):res;
    }

Using String Buffer class


    int ReverseInteger2(int n) {
        int flag=n<0?1:0;
        n=Math.abs(n);
        StringBuffer sb=new StringBuffer(Integer.toString(n));
        sb.reverse();
        int res=Integer.parseInt(sb.toString());
        return flag==1?res*-1:res;
    }

*************************Remove Element in-place**********

No additional DS allowed

void removeElement(int[] a,int val){
        int i=0,j=0;
        while(j<a.length){
            if(a[j]!=val){
                if(a[i]!=val){
                    i++;j++;
                }
                else{
                    a[i]=a[j];
                    a[j]=val;
                    i++;j++;
                }
            }
            else{
                j++;
            }
        }
        System.out.println(i);
    }

*********************Remove Duplicates From Sorted Array*****************

Using Hashing
void removeDuplicatesFromSorted(int[] a){
        int i=0,j=0;
        Map s=new HashMap<>();
        while(j<a.length){
            if(!s.containsKey(a[j])){
                a[i]=a[j];
                s.put(a[j],j);
                i++;
                j++;
            }
            else{
                j++;
            }
        }
        System.out.println("Number of Unique Elements: "+i);
    }

Using 2 pointers (complex)
void removeDuplicatesFromSorted2(int[] a){
        int i=0,j=0,c=1;
        while(j<a.length){
            if(a[j]==a[i]){
                c++;
                j++;
            }
            if(a[j]!=a[i]){
                if(c==1){
                    i++;
                    j++;
                    c=1;
                }
                else{
                    a[i+1]=a[j];
                    i++;
                    c=1;
                    j++;
                }
            }
        }

        System.out.println("Number of Unique Elements: "+(i+1));
    }

Using 2 pointers (easier)
void removeDuplicatesFromSorted3(int[] a){
        int i=1,j=1;
        while(j<a.length){
            if(a[j]!=a[j-1]){
                a[i]=a[j];
                i++;
                j++;
            }
            else{
                j++;
            }
        }
        System.out.println("Number of Unique Elements: "+(i));
    }

***********************3 Sum***************************

boolean threesum(int[] a,int x){
        Arrays.sort(a);
        for(int k=0;k<a.length;k++) {
            int i = 0, j = a.length - 1;
            int d=x-a[k];
            while(i<j) {
                if(a[i]+a[j]==d && i!=k && j!=k) {
                    return true;
                }
                else if(a[i]+a[j]>d) {
                    j--;
                }
                else
                    i++;
            }
        }
        return false;
    }

    void threesumPrint(int[] a,int x){
        Arrays.sort(a);
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        for(int k=0;k<a.length;k++) {
            int i = k+1, j = a.length - 1;
		//i=k+1 ensures unique triplets
            int d=x-a[k];
            while(i<j) {
                if(a[i]+a[j]==d && i!=k && j!=k) {
                    ArrayList<Integer> temp = new ArrayList<>();
                    temp.add(a[k]);
                    temp.add(a[i]);
                    temp.add(a[j]);
                    res.add(temp);
                    break;
                }
                else if(a[i]+a[j]>d) {
                    j--;
                }
                else
                    i++;
            }
        }
        for(ArrayList<Integer> i:res){
            for(int j:i){
                System.out.print(j+" ");
            }
            System.out.println();
        }
    }

********************Product of Array Except Self*******************

    void productExceptSelfWithoutDiv(int[] a){
        int p[]=new int[a.length];
        int s[]=new int[a.length];
        p[0]=1;
        s[a.length-1]=1;
        for(int i=1;i<a.length;i++){
            p[i]=p[i-1]*a[i-1];
        }
        for(int j=a.length-2;j>=0;j--){
            s[j]=s[j+1]*a[j+1];
        }
        for(int i=0;i<a.length;i++){
            System.out.print(p[i]*s[i]+" ");
        }
        System.out.println();
    }
    void productExceptSelf(int[] a){
        int tot=1;
        for(int i:a)
            tot*=i;
        for(int i:a)
            System.out.print(tot/i+" ");
        System.out.println();
    }

*******************Maximum in Sliding Window****************

    int[] slidingWindowMaximum(int[] a,int k){
        int res[]=new int[a.length-k+1];
        int z=0;
        Set<Integer> s=new TreeSet<>();
        for(int i=0;i<k;i++){
            s.add(a[i]);
        }
        res[z++]=Collections.max(s);
        for(int i=k;i<a.length;i++){
            s.remove(a[i-k]);
            s.add(a[i]);
            res[z++]=Collections.max(s);
        }
        return res;
    }

****************Maximum Sum of Contiguous Subarray of size k***************

int maxContiguousSubarraySumK(int[] a,int k){
        int maxsum=0,currSum=0;
        for(int i=0;i<k;i++){
            currSum+=a[i];
        }
        maxsum=currSum;
        for(int i=k;i<a.length;i++){
            currSum-=a[i-k];
            currSum+=a[i];
            maxsum=Math.max(maxsum,currSum);
        }
        return maxsum;
    }

****************Longest Substring Without Repeating Characters******************

    void longestSubstringWithoutRepeatingChars(String s){
        String ans="",curr="";
        for(int i=0;i<s.length();i++){
            if(curr.indexOf(s.charAt(i))!=-1){
                if(ans.length()<curr.length()){
                    ans=curr;
                    curr=""+s.charAt(i);
                }
            }
            else{
                curr=curr+s.charAt(i);
            }
        }
        System.out.println("Longest Substring Without Repeating Characters is: "+ans+" which is of length: "+ans.length());
    }

**************Symmetric Tree************************

Symmetric Binary tree

left ka right should be right ka left and vice versa

Node createSymmBinaryTree(){
        Node a=new Node(1);
        Node b=new Node(2);
        Node c=new Node(2);
        Node d=new Node(3);
        Node e=new Node(3);
        a.l=b;
        a.r=c;
        b.l=d;
        c.r=e;
        return a;
    }

    Node createNonSymmBinaryTree(){
        Node a=new Node(1);
        Node b=new Node(2);
        Node c=new Node(2);
        Node d=new Node(7);
        Node e=new Node(3);
        a.l=b;
        a.r=c;
        b.l=d;
        c.l=e;
        return a;
    }
    boolean checkIfSymmetricBinaryTree(){
        if(root==null)
            return true;
        Stack<Node> s=new Stack<>();
        s.push(root.l);
        s.push(root.r);
        while(!s.isEmpty()){
            Node a=s.pop();
            Node b=s.pop();
            if(a==null && b==null)
                continue;
            if(a==null || b==null || a.d!=b.d)
                return false;
            s.push(a.l);
            s.push(b.r);
            s.push(a.r);
            s.push(b.l);
        }
        return true;
    }

*********************FINISH***********************

SOME CODES HERE MAY BE MISSING, AS I THOGHT THEM TO BE TOO EASY THAT EVRYONE KNOWS IT
(LIKE LINEAR SEARCH ETC.)




Compiled By: Sooraj Tomar
https://www.linkedin.com/in/tomarsooraj/